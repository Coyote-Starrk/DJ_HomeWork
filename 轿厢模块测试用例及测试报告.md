# 轿厢模块测试用例及测试报告

## A. FLASH模块接口测试

### 	1.清除所有flash中保存的参数

接口函数：FLASH_CleanAllParam（）；

功能预期：擦除对应flash全部数据

测试结果：确认擦除成功（无BUG）

### 	2.向扇区的可写块添加一条数据

接口函数：uint8_t FLASH_AddParam(uint32_t pageAddress, SYSFloorMsg param)；

功能预期：自动添加一条param至flash块的最后一个可用位置。

测试结果：成功添加。（无BUG）

异常功能预期1：当flash被写满时，添加失败并返回0。

异常测试结果1：检测到写满，返回0。（无BUG）

### 3.按照内存参数表更新flash参数

接口函数：void FLASH_UpdateFlash(uint32_t pageAddress)；

功能预期：调用这个函数，会首先擦除对应flash块，然后将内存参数表的所有数据写回擦除后的flash

测试结果：flash块被重置，flash按照内存更新了参数。（无BUG）

#### 4.向flash新增一条数据

接口函数：void FLASH_AddOneParam(SYSFloorMsg param)

功能预期：调用本接口，可以先向分区2，后向分区1flash，添加一条参数。

测试结果：测试通过，先后顺序一致。（无BUG）

异常功能预期1：如果分区被写满，会调用FLASH_UpdateFlash接口擦除flash并按照内存参数重写分区

异常测试结果1：测试通过。（无BUG）

### 5.启动初始化，遍历flash起始地址至终止地址，将参数读入内存数组

接口函数：void FLASH_ModuleInit(void)

功能预期：模块初始化，初始化内存数组，并从flash读入相应参数保存到内存中。参数读入时会查看2分区是否比1分区多更新一条参数，如果有，则会同步到1分区。

测试结果：当两个flash保存的参数一致时且前后不冲突floorID和switchID时，测试通过。

异常功能预期1：当参数出现switchID冲突时，保证读到内存的参数不出问题

异常测试结果1：正常读出，冲突参数被后置参数覆盖，无BUG。

异常功能预期2：当参数出现floorID冲突时，保证读到内存的参数不出问题

异常测试结果2：正常读出，冲突参数被后置参数覆盖，无BUG。

__需要注意：本来这个函数需要执行参数校验，但若加入参数校验的逻辑程序会过于复杂且有些地方和原有设计冲突，因此这个接口的测试通过的条件为正常情况下执行不会出错__

## B. LORA模块接口测试

### 1.Lora模块初始化

接口函数：void Lora_ModuleInit(void);	

功能预期：初始化LORA硬件，调整工作模式，设置对应波特率，LORA地址信道定点传输工作状态等。

测试结果：能够按照拨码开关设置的地址和信道初始化模块地址。

__修改地址的功能前后测试了很多次，初始化函数能够顺利设置模块地址等参数，板子上电初始化完成后，使用客户端软件读配置，可以观察到LORA参数和预期一致。__

### 2.填充一帧报文，并调用LORA发送

接口函数：void LORA_SendMsg(ADDR_ToSend addr,SYS_MsgHead resMsg, char* payload,size_t payloadLen)

功能预期：填充一帧报文并执行DMA发送

测试结果：成功发送对应报文。（无BUG，这个是常用函数，测试过程中多次使用，不可能有问题）

__需要说的是，工程软件中前后始终未用到AUX口读LORA状态，函数接口LORA_SendMsg一定不会连续发送报文，所以消息发送一直没有出现过问题__

### 3.LORA相关GPIO控制

M0/M1/POWER/AUX四个GPIO的输入输出控制已在硬件遍历的时候完成测试。这里不重复测试。

## C. UWB测距模块

### 1.UWB模块初始化

接口函数：void UWB_ModuleInit(void)

功能预期：初始化串口等硬件资源，UWB上电，按照开关2重新设置UWB地址，初始化UWB为TAG0~8

测试结果：UWB初始化和地址设置没有问题，使用任意配置的UWB，只要执行过板子上电初始化，UWB地址都会按照拨码开关2的配置执行统一初始化。无BUG。

### 2.从UWB数据中读取距离信息

接口函数：void UWB_GetDistanceFromMsg(char* data)

功能预期：只要给与正确的UWB数据帧在内存中的首地址位置，即可读出距离信息并保存在uint32_t的变量中。

测试结果：这个是最频繁使用的接口之一，无BUG。

### 3.设置根据GPIO读出的拨码开关地址设置UWB的TAG地址

接口函数：void UWB_SetDeviceAddr()

功能预期：按照拨码开关2读出的ADDRL，向UWB发送对应参数，设置UWB的工作模式TAG0~7

测试结果：由UWB_ModuleInit调用这个接口，检查UWB修改后的参数，可得TAG地址已被正确修改。无BUG

## D. 拨码开关

拨码开关在硬件遍历的时候就已经验证过对应的功能，且LORA和UWB都在间接使用这个接口，根据两个模块的测试可验证，拨码开关对应的宏函数，无BUG。

## E. 数据灯控制

接收到报文数据的时候开启LED，延时100ms后关闭。逻辑测试没问题，就是看着有点怪。

## F. 0~127号继电器控制

### 1.GPIO初始化，包括板上电梯控制按钮，LED数据灯，拨码开关

函数接口：void GPIO_ModuleInit(void)

功能预期：调用过这个接口后，板上所有的继电器，扩展板继电器，拨码开关，LED都应初始化且正常工作。

测试方案：使用扩展板，按照ID：0~127逐个测试对应继电器的使能和使能控制。

调用函数接口：void GPIO_FloorButtonCtrl(int16_t floorID, CtrInput_TypeDef ctrInput)

测试结果：使用扩展板抽查测试ID为16,32,48,60,64,127的继电器，输出验证没有问题

## G. 手持操作器主要流程

### 1.下发任意参数（SET_ONE_PARAM）：

测试结果：参数添加完成。

### 2.擦除所有内存参数和flash参数（CLEAN_ALL_PARAM）：

测试结果：清除flash没有问题。

### 3.下发的参数中包含重复的继电器ID和floorID

测试结果：重复ID被覆盖，无BUG

## H.模拟机器人主要流程

### 1.在D0状态下接收A2/3/4应该向机器人回复DD

测试结果：流程正常

### 2.在D0状态下接收未被配置的楼层参数应向机器人回复DE，表示参数错误

测试结果：流程正常

### 3.在D0状态下接收正常配置的楼层参数会向机器人回复D1

测试结果：流程正常

### 4.在D1状态下接收AF指令，状态机会重置回D0

测试结果，流程正常

### 5.在D1状态下移动基站A0位置至floorNow位置的过程中，回复报文中floorNow字段会填充电梯当前楼层

测试结果，流程正常

### 6.在D1状态下，移动基站A0位置至floorNow位置，电梯更新自身状态到D2状态

测试结果，流程正常

### 7.在D1状态下，发送A2/3/4/5，会回复DD命令

测试结果，流程正常

### 8.任意两个消息间隔，超出10S就会执行短超时流程

测试结果，流程正常，超时时间可以随便修改

### 9.电梯迟迟处在开门流程没有收到机器人方的进入完成或者离开完成的指令，长超时之后断连

测试结果，流程正常，超时时间可以随便修改

### 10.在D2状态下，机器人发送A2指令，我方回复D2

测试结果，流程正常

### 11.在D2状态下，接收到机器人A3指令，状态机状态转移，开始关门并开始循环触发下一楼层按钮

测试结果，流程正常

### 12.在D3状态下，移动基站位置到floorDst位置，电梯将自身状态转移到D4，并停止循环触发楼层按钮

测试结果，流程正常

### 13.在D4状态下，接收到A4指令，回复自身状态D4

测试结果，流程正常

### 14，在D4状态下，接收到A5指令，重置任务，回复自身状态D0

测试结果，流程正常
